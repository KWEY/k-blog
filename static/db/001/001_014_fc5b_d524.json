{
	"title": "Media Source Extension",
	"id": "001_014_fc5b_d524",
	"time": "2019/1/13 下午5:39:26",
	"context": "<h2 id=\"articleHeader0\">2. MediaSource Object</h2><h3 id=\"articleHeader1\"><p>MediaSource对象表示HTMLMediaElement元素的一个媒体数据源。它会记录源的readyState和一个可以添加媒体数据去展示的SourceBuffer对象的列表。MediaSource对象由web应用创建然后绑定到HTMLMediaElement元素上。web应用通过添加SourceBuffer对象给sourceBuffers属性从而添加媒体数据到source中。当需要播放的时候，HTMLMediaElement从MediaSource对象中读取媒体数据。</p><p>每个MediaSource对象都由一个实时的可检索的range变量来存储归一化后的TimeRanges对象。当MediaSource对象创建的时候这个变量初始化为一个空的TimeRanges对象，通过setLiveSeekableRange() 和 clearLiveSeekableRange()方法来维护，然后通过HTMLMediaElement Extensions 来更改HTMLMediaElement.seekable属性。</p><pre><span id=\"idl-def-readystate\" readystate\"=\"\">enum <a href=\"https://w3c.github.io/media-source/#idl-def-readystate\" color:=\"\" rgb(3,=\"\" 69,=\"\" 117);=\"\" border-bottom:=\"\" 1px=\"\" solid=\"\" rgb(187,=\"\" 187,=\"\" 187);=\"\" text-decoration:=\"\" none;=\"\" padding:=\"\" 0px=\"\" 1px;=\"\" margin:=\"\" -1px;\"=\"\" style=\"font-family: &quot;Source Sans Pro&quot;, &quot;Helvetica Neue&quot;, Arial, sans-serif; font-size: 14px;\"><code style=\"display: inline !important;\">ReadyState</code></a><br> {\n    \"<a href=\"https://w3c.github.io/media-source/#dom-readystate-closed\">closed</a>\",\n    \"<a href=\"https://w3c.github.io/media-source/#dom-readystate-open\">open</a>\",\n    \"<a href=\"https://w3c.github.io/media-source/#dom-readystate-ended\">ended</a>\"\n};</span></pre><table><thead><tr><th>状态值</th><th>描述</th></tr></thead><tbody><tr><td>closed</td><td>表示source还没有绑定到media元素上</td></tr><tr><td>open</td><td>source被media元素打开并且有可用的SourceBuffer对象在sourceBuffers中</td></tr><tr><td>ended</td><td>source还被绑定在media元素上，但是endOfStream() 执行过了</td></tr></tbody></table><p><strong>构造函数</strong></p><pre><code>[Constructor]\ninterface MediaSource : EventTarget {\n    readonly attribute SourceBufferList    sourceBuffers;\n    readonly attribute SourceBufferList    activeSourceBuffers;\n    readonly attribute ReadyState          readyState;\n             attribute unrestricted double duration;\n             attribute EventHandler        onsourceopen;\n             attribute EventHandler        onsourceended;\n             attribute EventHandler        onsourceclose;\n    SourceBuffer addSourceBuffer(DOMString type);\n    void         removeSourceBuffer(SourceBuffer sourceBuffer);\n    void         endOfStream(optional EndOfStreamError error);\n    void         setLiveSeekableRange(double start, double end);\n    void         clearLiveSeekableRange();\n    static boolean isTypeSupported(DOMString type);\n};</code></pre></h3><h3 id=\"articleHeader1\">2.1 属性值</h3><h3><p><em>sourceBuffers</em>&nbsp;类型：SourceBufferList，只读<br>MediaSource相关的SourceBuffer列表，当readyState==\"closed\"的时候总是空的，一旦readyState变为\"open\"状态时，就可以通过 addSourceBuffer()方法添加SourceBuffer对象到列表中</p><p><em>activeSourceBuffers</em>&nbsp;类型：SourceBufferList，只读</p><p>sourceBuffers中selected video track, the enabled audio track(s), and the \"showing\" or \"hidden\" text track(s)的一个子集。</p><p><em>readyState</em>&nbsp;类型：ReadyState，只读<br>MediaSource对象的当前状态，刚创建的时候一定是‘closed’。</p><p><em>duration</em>&nbsp;类型：unrestricted double<br>MediaSource刚创建的时候，初始化值为NaN。<br>如何获取？</p><ol><li>如果readyState为closed，则返回NaN，这一步可以丢弃</li><li>返回该属性当前值<br>如何设置？</li><li>如果设置了负值或者NaN，会抛出TypeError异常，并丢弃剩余步骤</li><li>如果readyState不是open，会抛出InvalidStateError异常，并丢弃剩余步骤</li><li>sourceBuffers属性中的任何一个SourceBuffer的updating值为true, ，会抛出InvalidStateError异常，并丢弃剩余步骤</li><li>运行duration change algorithm算法可以设置新的duration给当前属性</li></ol><blockquote><p>Note<br>如果当前有更高end time的缓冲帧，duration change algorithm会调整新的更大的duration。<br>appendBuffer()和 endOfStream()方法会更新duration在特定的情况下。</p></blockquote><p><em>onsourceopen</em>&nbsp;类型：EventHandler<br>sourceopen事件的处理回调</p><p><em>onsourceended</em>&nbsp;类型：EventHandler<br>sourceended事件的处理回调</p><p><em>onsourceclose</em>&nbsp;类型：EventHandler<br>sourceclose事件的处理回调</p></h3><h3 id=\"articleHeader2\">2.2 方法</h3><h3><p><em>addSourceBuffer</em><br>入参：type， 返回SourceBuffer对象，调用如：</p><pre><code>sourceBuffer&nbsp;= ms.addSourceBuffer('video/mp4; codecs=\"avc1.4d401f\"');</code></pre><p>添加一个新的SourceBuffer对象到sourceBuffers属性，接下来ua需要执行以下步骤：</p><ol><li>1.如果<em>type</em>为空字符串（''），则抛出TypeError异常，并丢弃剩余步骤</li><li>2.如果<em>type</em>为不支持的MIME类型，则抛出 NotSupportedError异常，并丢弃剩余步骤</li><li>3.如果ua不能处理更多的SourceBuffer内容，则抛出QuotaExceededError异常，并丢弃剩余步骤</li></ol><blockquote><p>比如当媒体元素到了HAVE_METADATA状态的时候，ua就不支持播放中更多track的添加了</p></blockquote><ol><li>4.如果readyState不是open，则抛出InvalidStateError异常，并丢弃剩余步骤</li><li>5.常见一个新的SourceBuffer对象和相关资源</li><li>6.设置新对象的<em>generate timestamps flag</em>为相关类型的[MSE-REGISTRY] entry</li><li>7.如果generate timestamps flag值为true，设置新对象的mode属性为“sequence”，否则设置为“segments”</li><li>8.把新对象添加到sourceBuffers中，并且触发一个addsourcebuffer事件</li><li>9.返回这个新对象</li></ol><p><em>removeSourceBuffer</em></p><p>移除一个新的SourceBuffer对象从sourceBuffers属性，接下来ua需要执行以下步骤：<em><br></em></p><p><em>1.</em><span style=\"font-size: 14px;\">如果sourceBuffer指定了不在sourceBuffers中的对象，则抛出NotFoundError异常并中止这些步骤。</span></p><p><span style=\"font-size: 14px;\">2.</span><span style=\"font-size: 14px;\">如果sourceBuffer.updating属性等于true，则运行以下步骤：</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp;2.1如果缓冲区附加算法正在运行，则中止该算法。</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp;2.2将sourceBuffer.updating属性设置为false。</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp;2.3将任务排队以在sourceBuffer处触发名为abort的简单事件。</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp;2.4将任务排队以在sourceBuffer处触发名为updateend的简单事件。</span></p><p><em>3.</em><span style=\"font-size: 14px;\">让SourceBuffer audioTracks列表等于sourceBuffer.audioTracks返回的AudioTrackList对象。</span></p><p><span style=\"font-size: 14px;\">4.</span><span style=\"font-size: 14px;\">如果SourceBuffer audioTracks列表不为空，则运行以下步骤：</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; 4.1让HTMLMediaElement audioTracks列表等于HTMLMediaElement上audioTracks属性返回的AudioTrackList对象。&nbsp; &nbsp; &nbsp; 4.2对于SourceBuffer audioTracks列表中的每个AudioTrack对象，请运行以下步骤：</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4.2.1将AudioTrack对象上的sourceBuffer属性设置为null。</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;4.2.2从HTMLMediaElement audioTracks列表中删除AudioTrack对象。</span></p><blockquote><p>Note<br></p><p>这应该触发AudioTrackList [HTML51]逻辑来排队任务以触发名为removetrack的可信事件，该事件不会冒泡且不可取消，并且使用TrackEvent接口，并将track属性初始化为AudioTrack对象，位于HTMLMediaElement audioTracks名单。如果AudioTrack对象的enabled属性在此删除步骤开始时为true，那么这也应该触发AudioTrackList [HTML51]逻辑，将任务排队以在HTMLMediaElement audioTracks列表中触发名为change的简单事件<br></p></blockquote><p>&nbsp; &nbsp;4.3<span style=\"font-size: 14px;\">从SourceBuffer audioTracks列表中删除AudioTrack对象。</span></p><blockquote><p>Note<br></p><p>这应该触发AudioTrackList [HTML51]逻辑，将任务排队，以触发名为removetrack的可信事件，该事件不会冒泡且不可取消，并且使用TrackEvent接口，并将track属性初始化为AudioTrack对象，位于SourceBuffer audioTracks名单。如果AudioTrack对象的enabled属性在此删除步骤开始时为true，那么这也应该触发AudioTrackList [HTML51]逻辑来排队任务以在SourceBuffer audioTracks列表中触发名为change的简单事件</p></blockquote><ol><li>5.让SourceBuffer videoTracks列表等于sourceBuffer.videoTracks返回的VideoTrackList对象。</li><li>6.如果SourceBuffer videoTracks列表不为空，则运行以下步骤：</li><li>&nbsp; 6.1让HTMLMediaElement videoTracks列表等于HTMLMediaElement上videoTracks属性返回的&nbsp; &nbsp; &nbsp; VideoTrackList对象。</li><li>6.2对于SourceBuffer videoTracks列表中的每个VideoTrack对象，请运行以下步骤：</li><li>&nbsp; &nbsp; 6.2.1将VideoTrack对象上的sourceBuffer属性设置为null。</li><li>&nbsp; &nbsp; 6.2.2从HTMLMediaElement videoTracks列表中删除VideoTrack对象。</li></ol><blockquote><p>Note<br></p><p>这应该触发VideoTrackList [HTML51]逻辑来排队任务以激活名为removetrack的可信事件，该事件不会冒泡且不可取消，并且使用TrackEvent接口，其中track属性已初始化为VideoTrack对象，位于HTMLMediaElement videoTracks名单。如果VideoTrack对象上的selected属性在此删除步骤开始时为true，那么这也应触发VideoTrackList [HTML51]逻辑，将任务排队以在HTMLMediaElement videoTracks列表中触发名为change的简单事件</p></blockquote><ol><li>6.2.3从SourceBuffer videoTracks列表中删除VideoTrack对象。</li><blockquote><p>这应该触发VideoTrackList [HTML51]逻辑来排队任务以触发名为removetrack的可信事件，该事件不会冒泡且不可取消，并且使用TrackEvent接口，并将track属性初始化为VideoTrack对象，位于SourceBuffer videoTracks名单。如果VideoTrack对象上的selected属性在此删除步骤开始时为true，那么这也应触发VideoTrackList [HTML51]逻辑，将任务排队，以在SourceBuffer videoTracks列表中触发名为change的简单事件</p></blockquote></ol><p><em>7.</em><span style=\"font-size: 14px;\">让SourceBuffer textTracks列表等于sourceBuffer.textTracks返回的TextTrackList对象。</span></p><p><span style=\"font-size: 14px;\">8.如果SourceBuffer textTracks列表不为空，则运行以下步骤：</span></p><p><span style=\"font-size: 14px;\">&nbsp; 8.1让HTMLMediaElement textTracks列表等于HTMLMediaElement上textTracks属性返回的TextTrackList对象。</span></p><p><span style=\"font-size: 14px;\">&nbsp; 8.2对于SourceBuffer textTracks列表中的每个TextTrack对象，请运行以下步骤：</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; &nbsp;8.2.1将TextTrack对象上的sourceBuffer属性设置为null。</span></p><p><span style=\"font-size: 14px;\">&nbsp; &nbsp; &nbsp;8.2.2从HTMLMediaElement textTracks列表中删除TextTrack对象。</span></p><blockquote><p>Note</p><p>这应该触发TextTrackList [HTML51]逻辑，将任务排队，以触发名为removetrack的可信事件，该事件不会冒泡且不可取消，并且使用TrackEvent接口，并在HTMLMediaElement textTracks中将track属性初始化为TextTrack对象名单。如果TextTrack对象上的mode属性在此删除步骤开始时“显示”或“隐藏”，那么这也应该触发TextTrackList [HTML51]逻辑，将任务排队以在HTMLMediaElement textTracks列表中触发名为change的简单事件。</p></blockquote><ol><li>8.2.3从SourceBuffer textTracks列表中删除TextTrack对象。</li><blockquote><p>这应该触发TextTrackList [HTML51]逻辑来排队任务以触发名为removetrack的可信事件，该事件不会冒泡且不可取消，并且使用TrackEvent接口，并将track属性初始化为TextTrack对象，位于SourceBuffer textTracks名单。如果TextTrack对象上的mode属性在此删除步骤开始时“显示”或“隐藏”，那么这也应该触发TextTrackList [HTML51]逻辑来排队任务以在SourceBuffer textTracks列表中触发名为change的简单事件。</p></blockquote></ol><p>9.如果sourceBuffer在activeSourceBuffers中，则从activeSourceBuffers中删除sourceBuffer并对任务进行排队，以在activeSourceBuffers返回的SourceBufferList中触发名为removedourcebuffer的简单事件。10.从sourceBuffers中删除sourceBuffer并对任务进行排队，以在SourceBuffers返回的SourceBufferList中触发名为removedourcebuffer的简单事件。</p><p>11.销毁sourceBuffer的所有资源。</p><p><em>endOfStream</em><br></p><p>入参：error（EndOfStreamError），无返回值</p><ul><li>setLiveSeekableRange*<br>更新 HTMLMediaElement Extensions元素的live seekable range变量</li><li>clearLiveSeekableRange*</li><li>isTypeSupported* static<br>检测MediaSource对象是否支持创建特定MIME类型的SourceBuffer</li></ul><blockquote><p>只代表浏览器是否支持的能力，不代表addSourceBuffer()方法有足够的资源创建新的SourceBuffer</p></blockquote></h3><h3 id=\"articleHeader3\">2.3 事件</h3><h3><table><thead><tr><th>事件名称</th><th>描述</th></tr></thead><tbody><tr><td>sourceopen</td><td>readyState 从close到open 或 从ended到open</td></tr><tr><td>sourceended</td><td>readyState 从open到ended</td></tr><tr><td>sourceclose</td><td>readyState 从open到closed 或 从open到ended</td></tr></tbody></table><br></h3>"
}